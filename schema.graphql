# Slimmed Polymarket Subgraph Schema - Performance Optimized
# Removed bloat while keeping core analytical value
# Based on Goldsky patterns but more comprehensive

# =============================================================================
# CORE ENTITIES
# =============================================================================

type Global @entity(immutable: false) {
  "Singleton entity for global statistics"
  id: ID!
  
  # Market Statistics
  numConditions: Int!
  numOpenConditions: Int!
  numClosedConditions: Int!
  numMarkets: Int!
  numActiveMarkets: Int!
  
  # User Statistics
  numTraders: BigInt!
  numUniqueTraders: BigInt!
  
  # Trading Statistics
  tradesQuantity: BigInt!
  buysQuantity: BigInt!
  sellsQuantity: BigInt!
  
  # Volume Statistics (raw values only - no scaled bloat)
  collateralVolume: BigInt!
  collateralBuyVolume: BigInt!
  collateralSellVolume: BigInt!
  collateralFees: BigInt!
  
  # Timestamps
  lastUpdated: BigInt!
}

type Account @entity(immutable: false) {
  "User address"
  id: ID!
  
  # Account metadata
  creationTimestamp: BigInt!
  lastSeenTimestamp: BigInt!
  lastTradedTimestamp: BigInt!
  isActive: Boolean!
  
  # Trading statistics (raw values only)
  numTrades: BigInt!
  collateralVolume: BigInt!
  
  # P&L tracking (raw values only)
  totalRealizedPnl: BigInt!
  totalUnrealizedPnl: BigInt!
  totalFeesPaid: BigInt!
  
  # Advanced P&L metrics
  winRate: BigDecimal!
  profitFactor: BigDecimal!
  maxDrawdown: BigInt!
  
  # Relationships using @derivedFrom (no large arrays)
  positions: [MarketPosition!] @derivedFrom(field: "user")
  transactions: [Transaction!] @derivedFrom(field: "user")
  splits: [Split!] @derivedFrom(field: "stakeholder")
  merges: [Merge!] @derivedFrom(field: "stakeholder")
  redemptions: [Redemption!] @derivedFrom(field: "redeemer")
  marketProfits: [MarketProfit!] @derivedFrom(field: "user")
  tokenPositions: [TokenPosition!] @derivedFrom(field: "user")
  userStats: UserStats @derivedFrom(field: "user")
}

type Collateral @entity(immutable: false) {
  "Token address"
  id: ID!
  name: String!
  symbol: String!
  decimals: Int!
  
  # Usage statistics (raw values only)
  numMarkets: Int!
  totalVolume: BigInt!
  
  # Relationships using @derivedFrom
  splits: [Split!] @derivedFrom(field: "collateralToken")
  merges: [Merge!] @derivedFrom(field: "collateralToken")
  redemptions: [Redemption!] @derivedFrom(field: "collateralToken")
}

# =============================================================================
# CONDITIONAL TOKEN FRAMEWORK
# =============================================================================

type Condition @entity(immutable: false) {
  id: ID!
  oracle: Bytes!
  questionId: Bytes!
  outcomeSlotCount: Int!
  
  # Resolution data
  resolutionTimestamp: BigInt
  resolutionHash: Bytes
  payoutNumerators: [BigInt!]
  payoutDenominator: BigInt
  
  # Relationships using @derivedFrom (no large arrays)
  markets: [Market!] @derivedFrom(field: "condition")
  splits: [Split!] @derivedFrom(field: "condition")
  merges: [Merge!] @derivedFrom(field: "condition")
  redemptions: [Redemption!] @derivedFrom(field: "condition")
  marketProfits: [MarketProfit!] @derivedFrom(field: "condition")
  
  # Statistics (raw values only)
  numMarkets: Int!
  totalVolume: BigInt!
}

type Market @entity(immutable: false) {
  "Market identifier (condition + outcome index)"
  id: ID!
  condition: Condition!
  outcomeIndex: BigInt!
  
  # Market metadata
  isActive: Boolean!
  isResolved: Boolean!
  resolutionTimestamp: BigInt
  
  # Trading data (raw values only)
  totalVolume: BigInt!
  numTrades: BigInt!
  numBuyers: Int!
  numSellers: Int!
  
  # Price data (simplified - no PricePoint bloat)
  currentPrice: BigDecimal
  lastPriceUpdate: BigInt!
  
  # Relationships using @derivedFrom (no large arrays)
  positions: [MarketPosition!] @derivedFrom(field: "market")
  transactions: [Transaction!] @derivedFrom(field: "market")
  tokenPositions: [TokenPosition!] @derivedFrom(field: "market")
}

# =============================================================================
# POSITION TRACKING
# =============================================================================

type MarketPosition @entity(immutable: false) {
  "User + Market ID"
  id: ID!
  user: Account!
  market: Market!
  
  # Position data (raw values only)
  quantityBought: BigInt!
  quantitySold: BigInt!
  netQuantity: BigInt!
  valueBought: BigInt!
  valueSold: BigInt!
  netValue: BigInt!
  feesPaid: BigInt!
  
  # P&L tracking (raw values only)
  realizedPnl: BigInt!
  unrealizedPnl: BigInt!
  
  # Timestamps
  firstTradeTimestamp: BigInt!
  lastTradeTimestamp: BigInt!
}

type MarketProfit @entity(immutable: false) {
  "User + Condition ID"
  id: ID!
  user: Account!
  condition: Condition!
  profit: BigInt!
}

# =============================================================================
# GOLDSKY-INSPIRED ENTITIES (SIMPLIFIED)
# =============================================================================

type TokenPosition @entity(immutable: false) {
  "User Address + Token ID"
  id: ID!
  user: Account!
  market: Market!
  tokenId: BigInt!
  amount: BigInt!
  avgPrice: BigInt!
  realizedPnl: BigInt!
  totalBought: BigInt!
}

type UserStats @entity(immutable: false) {
  "User Address"
  id: ID!
  user: Account!
  totalVolume: BigInt!
  totalTrades: BigInt!
  totalPnl: BigInt!
  winRate: BigDecimal!
}

type SimpleUserPosition @entity(immutable: true) {
  "User + Market simplified"
  id: ID!
  user: String!
  market: String!
  position: BigInt!
  pnl: BigInt!
}

type SimpleMarketData @entity(immutable: true) {
  "Market ID"
  id: ID!
  volume: BigInt!
  price: BigDecimal!
  participants: Int!
}

# =============================================================================
# TRADING DATA (SIMPLIFIED - NO GAS BLOAT)
# =============================================================================

enum TradeType {
  Buy
  Sell
}

type Transaction @entity(immutable: true) {
  "Transaction hash"
  id: ID!
  type: TradeType!
  timestamp: BigInt!
  blockNumber: BigInt!
  
  # Participants
  user: Account!
  market: Market!
  
  # Trade details (core only - no gas/scaled bloat)
  tradeAmount: BigInt!
  feeAmount: BigInt!
  outcomeTokensAmount: BigInt!
  outcomeIndex: BigInt!
  price: BigDecimal!
}

# =============================================================================
# ORDERBOOK DATA (SIMPLIFIED - NO ANALYTICS BLOAT)
# =============================================================================

type Orderbook @entity(immutable: false) {
  "Token ID"
  id: ID!
  
  # Core trading statistics only (no analytics bloat)
  tradesQuantity: BigInt!
  buysQuantity: BigInt!
  sellsQuantity: BigInt!
  collateralVolume: BigInt!
  collateralBuyVolume: BigInt!
  collateralSellVolume: BigInt!
  totalFees: BigInt!
  
  # Relationships using @derivedFrom (no large arrays)
  orders: [OrderFilledEvent!] @derivedFrom(field: "orderbook")
}

type OrderFilledEvent @entity(immutable: true) {
  "Transaction hash + Order hash"
  id: ID!
  transactionHash: Bytes!
  timestamp: BigInt!
  blockNumber: BigInt!
  
  # Order details
  orderHash: Bytes!
  maker: Bytes!
  taker: Bytes!
  makerAssetId: BigInt!
  takerAssetId: BigInt!
  makerAmountFilled: BigInt!
  takerAmountFilled: BigInt!
  fee: BigInt!
  
  # Market data
  orderbook: Orderbook!
  side: String!
  price: BigDecimal!
  size: BigInt!
}

type OrdersMatchedEvent @entity(immutable: true) {
  "Transaction hash"
  id: ID!
  timestamp: BigInt!
  blockNumber: BigInt!
  
  # Match details
  makerAssetID: BigInt!
  takerAssetID: BigInt!
  makerAmountFilled: BigInt!
  takerAmountFilled: BigInt!
}

# =============================================================================
# POSITION MANAGEMENT
# =============================================================================

type Split @entity(immutable: true) {
  "Transaction hash"
  id: ID!
  timestamp: BigInt!
  blockNumber: BigInt!
  
  # Participants
  stakeholder: Account!
  collateralToken: Collateral!
  
  # Split details
  parentCollectionId: Bytes!
  condition: Condition!
  partition: [BigInt!]!
  amount: BigInt!
}

type Merge @entity(immutable: true) {
  "Transaction hash"
  id: ID!
  timestamp: BigInt!
  blockNumber: BigInt!
  
  # Participants
  stakeholder: Account!
  collateralToken: Collateral!
  
  # Merge details
  parentCollectionId: Bytes!
  condition: Condition!
  partition: [BigInt!]!
  amount: BigInt!
}

type Redemption @entity(immutable: true) {
  "Transaction hash"
  id: ID!
  timestamp: BigInt!
  blockNumber: BigInt!
  
  # Participants
  redeemer: Account!
  collateralToken: Collateral!
  
  # Redemption details
  parentCollectionId: Bytes!
  condition: Condition!
  indexSets: [BigInt!]!
  payout: BigInt!
}

# =============================================================================
# ANALYTICS (DAILY ONLY - NO HOURLY BLOAT)
# =============================================================================

type DailyStats @entity(immutable: false) {
  "YYYY-MM-DD format"
  id: ID!
  date: String!
  timestamp: BigInt!
  
  # Trading stats (raw values only)
  numTrades: BigInt!
  numTraders: Int!
  volume: BigInt!
  fees: BigInt!
  
  # Market stats
  numActiveMarkets: Int!
  numNewMarkets: Int!
  numResolvedMarkets: Int!
}
